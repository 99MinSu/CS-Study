# 동기와 비동기

![image](https://github.com/user-attachments/assets/4b8b0b38-cb1b-41f8-bc8f-b33426c68890)

### 1. 동기(Synchronous: 동시에 일어나는)

- 동기는 말 그대로 동시에 일어난다는 뜻이다. 요청과 그 결과가 동시에 일어난다는 약속이다.

바로 요청을 하면 시간이 얼마나 걸리던지 요청한 자리에서 결과가 주어져야 한다.

순서에 맞춰 진행되는 장점이 있지만,  여러 가지 요청을 동시에 처리할 수 없다.

위 그림의 (a)처럼 커피 주문을 받고 나올 때까지 기다리는 것이 동기 방식의 예시라고 할 수 있다.

### 2. 비동기(Asynchronous: 동시에 일어나지 않는)

- 비동기는 동시에 일어나지 않는다를 의미한다. 요청과 결과가 동시에 일어나지 않을 거라는 약속이다.

하나의 요청에 따른 응답을 즉시 처리하지 않아도, 그 대기 시간 동안 또 다른 요청에 대해 처리 가능한 방식이다.

여러 개의 요청을 동시에 처리할 수 있는 장점이 있지만 동기 방식보다 속도가 떨어질 수도 있다.

위 그림의 (b)처럼 점원 한명이 커피 주문을 받고 다른 점원이 커피를 건네주는 것이 비동기 방식의 예시다.

### 동기와 비동기는 상황에 따라서 각각의 장단점이 있다.

동기방식은 설계가 매우 간단하고 직관적이지만 결과가 주어질 때까지 아무것도 못하고 대기해야 하는 단점이 있고,

비동기방식은 동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있는 장점이 있다.

### 동기방식의 예

![image](https://github.com/user-attachments/assets/88253f07-01f1-4d7c-a9ab-a87af3d4145b)


1. A의 계좌는 10,000원을 뺄 생각을 하고 있다.

2. A의 계좌가 B의 계좌에 10,000원을 송금한다.

3. B의 계좌는 10,000원을 받았다는 걸 인지하고, A의 계좌에 10,000원을 받았다고 전송한다.

4. A, B 계좌 각각 차감과 증가가 동시에 발생한다.

- A의 계좌와 B의 계좌는 서로 요청과 응답(1~3번 과정)을 확인한 후 같은 일을동시에 진행했다.(4번 과정)

'계좌이체'같은 작업은 동기방식으로 처리해야 A에서 보냈는데 B에서 못 받는 상황이 없을 것이다.

반대로 비동기 방식은 위의 예제처럼 노드 사이의 작업 처리 단위를 동시에 맞추지 않아도 된다.

### 비동기 방식의 예

![image](https://github.com/user-attachments/assets/8c5a4cf2-7631-42b7-9cfc-a1cdd065bfc2)


1. 학생은 시험문제를 푼다.

2. 시험문제를 모두 푼 학생은 선생에게 전송한다.

3. 선생은 학생의 시험지를 채점한다.

4. 채점이 다 된 시험지를 학생에게 전송한다.

5. 학생은 선생이 전송한 시험지를 받아 결과를 확인한다.

- 학생과 선생은 시험지라는 연결고리가 있지만 시험지에 행하는 행위(목적)는 서로 다르다.

학생은 시험지를 푸는 역할을 하고 선생은 시험지를 채점하는 역할을 한다.

서로의 행위(목적)가 다르기 때문에 둘의 작업 처리 시간은 일치하지 않고, 일치하지 않아도 된다.

동기와 비동기는 어떤 작업 혹은 그와 연관된 작업을 처리하고자 하는 시각의 차이이다.

동기는 추구하는 같은 행위(목적)가 동시에 이루어지며,

비동기는 추구하는 행위(목적)가 다를 수도 있고, 동시에 이루어지지도 않는다.

비동기 방식 예제를 통해 블록과 논 블록의 차이를 간략하게 설명하면,

학생이 시험지를 선생에게 건넨 후 가만히 앉아 채점이 끝나 시험지를 돌려받기만을 기다린다면 학생은 블록 상태이다.

하지만 학생이 시험지를 건넨 후 선생에게 채점이 완료되었다는 전송을 받기 전까지 다른 과목을 공부한다거나 게임을 한다거나 다른 일을 하게 되면 학생의 상태는 논 블록 상태이다.

## 보통 블럭(Blocking)과 동기(Synchronous)가 같고 넌블럭(Non-Blocking)과 비동기(Asynchoronous)가 같은 개념이라고 생각하기 쉽지만 별개의 개념이라는것을 알아야한다.

블럭/넌블럭은 함수호출에서의 이야기. 기술적으로 명확히 구분된다.

- **Block호출된 함수**가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 **호출한 함수**에게 바로 return하지 않으면 블럭이다.
- **Non-Block호출된 함수**가 자신이 할 일을 마치지 않았더라도 바로 제어권을 바로 return하여 **호출한 함수**가 다른 일을 진행할 수 있도록 하면 넌블럭이다.

동기/비동기는 행위에 대한 이야기. 기술적으로는 구분되지 않지만 추상적으로 구분한다.

- **Synchronous**
    
    **호출된 함수**의 수행 결과 및 종료를 **호출된 함수 뿐 아니라 호출한 함수도** 함께 신경쓰면 동기이다.
    
- **Asynchoronous**
    
    **호출된 함수**의 수행 결과 및 종료를 **호출된 함수 혼자** 직접 신경쓰고 처리하면 비동기이다.
    
![image](https://github.com/user-attachments/assets/0bea7c51-9bea-418a-b726-20e789cf59a6)



이제 이 개념들이 조합된 것을 이해해보자.

- **동기 & 블로킹**
    
![image](https://github.com/user-attachments/assets/3d0debc9-f89e-4b5a-8f09-5f436e9b85a3)

    
> 손님: 아메리카 주문
> 
> 
> 직원: 아메리카노 만드는중
> 
> 손님: (그 자리에 서서 기다리는중. 결과가 궁금함. 테이블 못가고 서있음.)
> 
- **비동기 & 블로킹**

![image](https://github.com/user-attachments/assets/96882455-1524-4040-a80d-0c671e081090)



비동기 & 블로킹는 결국 다른 작업이 끝날 때를 기다려야 하기 때문에 동기 & 블로킹와 비슷한 효율이 나온다.

> 손님: 아메리카노 주문
> 
> 
> 직원 : 아메리카노 만드는중
> 
> 손님 : (안 궁금함. 테이블에 가고 싶지만 못 가고 서있음.)
> 

- **동기 & 논블로킹**

논블로킹으로 자신의 작업을 계속하고 있지만 다른 작업과의 동기를 위해 계속해서 다른 작업이 끝났는지 조회한다. 즉, 호출된 함수가 호출한 함수에게 제어권을 바로 return하여 호출한 함수가 다른 업무를 볼 수 있었음(Non-Blocked)에도 불구하고, 여전히 호출된 함수의 업무 결과에만 계속 함께 신경쓰느라(Synchronous) 제 할 일을 못하게 되는 현상이 일어난다. 동기 & 논블로킹도 효율이 좋지 않다.

![image](https://github.com/user-attachments/assets/b729d6cf-1d6e-4357-abb4-5ab5f82d9afe)


> 손님: 아메리카노 주문
> 
> 
> 직원 : 아메리카노 만드는중
> 
> 손님 : 재촉
> 

- **비동기 & 논블로킹**

자원이 충분하다면 효율이 좋다. 자신의 작업이 멈추지도 않고, 다른 주체가 하는 작업의 결과가 나왔을 때 콜백을 설정하기도 한다. 다른 주체에게 작업을 맡겨 놓고 자신이 하던 일을 계속할 수 있기 때문에 해야 할 작업이 대규모이고, 동기가 필요하지 않을 때 효과적이다.

![image](https://github.com/user-attachments/assets/8a636e39-cb04-4181-9630-c3de29017e97)


> 손님: 아메리카노 주문
> 
> 
> 직원 : 아메리카노 만드는중
> 
> 손님 : 자리가서 SNS, 유튜브 시청
> 
> 직원 : 아메리카노 제작 완료
>
