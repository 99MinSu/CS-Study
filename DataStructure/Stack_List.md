Stack, List
=====
## Stack
: 쌓다, 쌓이다와 같은 뜻을 가진 용어로, 데이터를 순서대로 쌓는 자료구조이다.

## 특징

- **후입선출** (LIFO : Last In First Out) 구조 : 먼저 들어온 데이터가 나중에 빠져나가는 구조
- **단방향 입출력** 구조 : 데이터의 들어오는 방향과 나가는 방향이 같다.
- 인터럽트처리, 수식의 계산, 서브루틴의 복귀 번지 저장 등에 쓰임
- 데이터를 **하나씩만** 넣고 뺄 수 있다.
- **깊이 우선 탐색(DFS)**에 이용된다.
- **재귀 함수**의 동작 흐름과 같은 구조를 가진다.

## 사용법

```java
Stack<Integer> stack = new Stack<>(); //int형 스택 선언
stack.push(1);     // stack에 값 1 추가
stack.push(2);     // stack에 값 2 추가

stack.peek();     // stack의 가장 상단의 값 출력

stack.size();      // stack의 크기 출력 : 2

stack.pop();       // stack에 값 제거
stack.clear();     // stack의 전체 값 제거 (초기화)

stack.empty();     // stack이 비어있는제 check (비어있다면 true)
stack.contains(1) // stack에 1이 있는지 check (있다면 true)
```

# List

:  배열과 같이 객체를 일렬로 늘어놓은 구조를 가지고 있다. 객체를 인덱스(index)로 관리하기 때문에 객체를 저장하면 자동으로 인덱스가 부여되고, 인덱스로 객체를 검색, 추가, 삭제할 수 있는 등의 기능을 제공한다.

- List 인터페이스를 구현한 클래스로는 ArrayList, Vector, LinkedList, Stack 등이 있다. 가장 많이 사용되는것은 ArrayList와 LinkedList이다.

## 특징

- 순서가 있고 중복을 허용한다.
- 인덱스로 관리하기 때문에 인덱스로 접근이 가능하다.
- 크기가 가변적이다.

---

## ArrayList

: List 인터페이스를 구현한 클래스로 컬렉션 프레임워크에서 가장 많이 사용된다. 기능적으로는 Vector와 동일하지만 Vector를 개선한 것이므로 Vector 보다 많이 사용된다.

객체가 **인덱스로 관리**된다는 점에서 배열과 유사하다. 그러나 배열은 생성될 때 크기가 고정되며, 크기를 변경할 수 없지만 ArrayList는 저장 용량을 초과하여 객체들이 추가되면, **자동으로 저장용량이 늘어나게 된다**. 또한 데이터가 연속적으로 존재하여 데이터의 순서가 **유지**된다.

## LinkedList

: 

ArrayList와 배열은 모든 데이터가 연속적으로 존재하지만, LinkedList에는 **불연속적**으로 존재하며, 이 데이터는 서로 연결되어 있다. LinkedList 컬렉션은 데이터를 **효율적으로 추가, 삭제, 변경하기 위해 사용한다.**

LinkedList의 각 요소(node)들은 자신과 연결된 이전 및 다음 요소의 주소값과 데이터로 구성되어 있다.

LinkedList에서 데이터를 삭제하려면, 삭제하고자 하는 요소의 이전 요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경한다. 링크를 끊어주는 방식이다. **배열처럼 데이터를 이동하기 위해 복사할 필요가 없기 때문에 처리 속도가 훨씬 빠르다.** 데이터를 추가할 때에도 마찬가지이다.

---

## **ArrayList VS LinkedList**

ArrayList는 다음과 같은 상황에 **강점**을 지닌다.

- 데이터를 순차적으로 추가하거나 삭제하는 경우
    - 순차적으로 추가한다는 것은 0번 인덱스에서부터 데이터를 추가하는 것을 의미한다.
    - 순차적으로 삭제한다는 것은 마지막 인덱스에서부터 데이터를 삭제하는 것을 의미한다.
- 데이터를 읽어들이는 경우
    - 인덱스를 통해 바로 데이터에 접근할 수 있으므로 검색이 빠르다.

다음과 같은 상황에서 **효율적이지 못하다.**

- 중간에 데이터를 추가하거나, 삭제하는 경우
    - 추가 또는 삭제 시, 해당 데이터의 뒤에 위치한 값들을 뒤로 밀어주거나 앞으로 당겨주어야 한다.

LinkedList는 다음과 같은 상황에 강점을 가진다.

- 중간에 위치하는 데이터를 추가하거나, 삭제하는 경우
    - 데이터를 중간에 추가, 삭제하는 경우 Prev와 Next의 주소값만 변경하면 되므로, 다른 요소들을 이동시킬 필요가 없다.

**따라서 데이터를 중간에 추가, 삭제하는 경우, LinkedList는 ArrayList보다 빠른 속도를 보여준다.**

데이터의 잦은 변경이 예상될 땐 LinkedList,  데이터의 개수가 변하지 않는다면 ArrayList를 사용하는 것이 좋다.

### 참고자료

https://pongic.tistory.com/3

https://ittrue.tistory.com/200

https://coding-factory.tistory.com/601
